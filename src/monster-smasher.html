<!DOCTYPE HTML>
<title>Animation Object</title>

<canvas width="128" height+"128"></canvas>

<script>

//Create the monster object
let monster = {
  //The monster's image file and the size of each frame cell
  IMAGE: "../images/monsterTileSheet.png",
  SIZE: 128,
  COLUMNS: 3,

  //The numbers of the animation frames and the starting frames
  numberOfFrames: 5,
  currentFrame: 0,

  //Properties of the animation cell's X and y positions on the tile sheet.
  //They're 0 when the object first loads
  sourceX: 0,
  sourceY: 0,

  //A variable to control the direction of the loop
  forward: true,

  //States
  HIDING: 0,
  JUMPING: 1,
  state: this.HIDING,

  //A propery to stor the fandom timer
  waitTime: undefined,

  //A method to find a random animation start time
  findWaitTime: function()
  {
    this.waitTime = Math.ceil(Math.random() * 60);
  },

  //The monster's updateAnimation method
  updateAnimation: function()
  {

    //Figure out the monster's state
    if(this.waitTime > 0 || this.waitTime === undefined)
    {
      this.state = this.HIDING;
    }
    else
    {
      this.state = this.JUMPING;
    }

    //Switch the mosters action based on its state
    switch(this.state)
    {
      case this.HIDING:
        this.currentFrame = 0;
        this.waitTime--;
        break;

      case this.JUMPING:
        //if the last frame has been reached, set forward to false
        if(this.currentFrame === this.numberOfFrames)
        {
          this.forward = false;
        }

        //If the first frame has been reached, set forward to true
        if(this.currentFrame === 0 && this.forward === false)
        {
          //Set forward to true, find a new waitTime,
          //set the state to HIDING and break the switch statement
          this.forward = true;
          this.findWaitTime();
          this.state = this.HIDING;
          break;
        }

        //Add 1 to the currentFrame if forward is true, subtract 1 if it's false
        if(this.forward)
        {
          this.currentFrame++;
        }
        else
        {
          this.currentFrame--;
        }
    }

    //Find the frame's correct column and row on the tilesheet
    this.sourceX = Math.floor(this.currentFrame % this.COLUMNS) * this.SIZE;
    this.sourceY = Math.floor(this.currentFrame / this.COLUMNS) * this.SIZE;
  }
};

//Set up the canvas and drawing surface
let canvas = document.querySelector("canvas");
let drawingSurface = canvas.getContext("2d");

//Load the animation tilesheet
let image = new Image();
image.addEventListener("load", loadHandler, false);
image.src = monster.IMAGE;

function loadHandler()
{
  //Start the animation
  updateAnimation();
}

function updateAnimation()
{
  //Set a timer to call updateAnimation every 300 milliseconds
  setTimeout(updateAnimation, 300);

  //Update the monster's animation frames
  monster.updateAnimation();

  //Render the animations
  render();
}

function render()
{
  //Clear the canvas of any previous frames
  drawingSurface.clearRect(0, 0, canvas.width, canvas.height);

  //Draw the monster's current animation frames
  drawingSurface.drawImage
  (
    image,
    monster.sourceX, monster.sourceY, monster.SIZE, monster.SIZE,
    0, 0, monster.SIZE, monster.SIZE
  );
}


</script>
